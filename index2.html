<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Advanced RGB Hover Effect</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      background: #000;
      color: #fff;
      font-family: system-ui, -apple-system, sans-serif;
      overflow-x: hidden;
    }

    #canvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 10;
    }

    .content {
      position: relative;
      z-index: 0;
      padding: 4rem 2rem;
    }

    h1 {
      text-align: center;
      font-size: clamp(2rem, 5vw, 4rem);
      margin-bottom: 3rem;
      background: linear-gradient(45deg, #ff00ff, #00ffff, #ff00ff);
      background-size: 200% 200%;
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      animation: gradientShift 3s ease infinite;
    }

    @keyframes gradientShift {
      0%, 100% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
    }

    .gallery {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      gap: 2rem;
      max-width: 1400px;
      margin: 0 auto;
    }

    .img-wrapper {
      aspect-ratio: 1;
      overflow: hidden;
      border-radius: 0.5rem;
      position: relative;
      cursor: pointer;
      transition: transform 0.3s ease;
    }

    .img-wrapper:hover {
      transform: scale(0.98);
    }

    .hover-image {
      width: 100%;
      height: 100%;
      object-fit: cover;
      opacity: 0;
    }

    .footer {
      text-align: center;
      color: #666;
      margin-top: 4rem;
      font-size: 0.9rem;
    }

    @media (max-width: 768px) {
      .content {
        padding: 2rem 1rem;
      }
      
      .gallery {
        gap: 1.5rem;
      }
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  
  <div class="content">
    <h1>Interactive Gallery</h1>
    
    <div class="gallery">
      <div class="img-wrapper">
        <img src="https://images.unsplash.com/photo-1518791841217-8f162f1e1131?w=800&h=800&fit=crop" alt="Cat 1" class="hover-image">
      </div>
      <div class="img-wrapper">
        <img src="https://images.unsplash.com/photo-1514888286974-6c03e2ca1dba?w=800&h=800&fit=crop" alt="Cat 2" class="hover-image">
      </div>
      <div class="img-wrapper">
        <img src="https://images.unsplash.com/photo-1529778873920-4da4926a72c2?w=800&h=800&fit=crop" alt="Cat 3" class="hover-image">
      </div>
      <div class="img-wrapper">
        <img src="https://images.unsplash.com/photo-1573865526739-10c1dd7fb965?w=800&h=800&fit=crop" alt="Cat 4" class="hover-image">
      </div>
      <div class="img-wrapper">
        <img src="https://images.unsplash.com/photo-1495360010541-f48722b34f7d?w=800&h=800&fit=crop" alt="Cat 5" class="hover-image">
      </div>
      <div class="img-wrapper">
        <img src="https://images.unsplash.com/photo-1574158622682-e40e69881006?w=800&h=800&fit=crop" alt="Cat 6" class="hover-image">
      </div>
    </div>
    
    <p class="footer">Hover, scroll, and watch the magic happen ✨</p>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
  <script type="module">
    const canvas = document.querySelector('#canvas');
    const scene = new THREE.Scene();

    const fov = 75;
    const getCameraDistance = () => window.innerHeight / (2 * Math.tan((fov * Math.PI) / 360));

    const camera = new THREE.PerspectiveCamera(
      fov,
      window.innerWidth / window.innerHeight,
      0.1,
      5000
    );
    camera.position.z = getCameraDistance();

    const renderer = new THREE.WebGLRenderer({
      canvas,
      antialias: true,
      alpha: true,
    });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);

    /* ---------------- RAYCASTER & SMOOTH MOUSE ---------------- */
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2(-1, -1);
    const targetMouse = new THREE.Vector2(-1, -1);
    const smoothMouse = new THREE.Vector2(-1, -1);

    window.addEventListener('mousemove', (event) => {
      targetMouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      targetMouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
    });

    // Smooth mouse lerp
    function updateSmoothMouse() {
      smoothMouse.x += (targetMouse.x - smoothMouse.x) * 0.1;
      smoothMouse.y += (targetMouse.y - smoothMouse.y) * 0.1;
      mouse.copy(smoothMouse);
    }

    /* ---------------- IMG → PLANE WITH ADVANCED EFFECTS ---------------- */
    const imgs = document.querySelectorAll('.hover-image');
    const planes = [];
    let time = 0;

    imgs.forEach(img => {
      const rect = img.getBoundingClientRect();
      const texture = new THREE.TextureLoader().load(img.src);
      texture.minFilter = THREE.LinearFilter;

      const geometry = new THREE.PlaneGeometry(rect.width, rect.height);
      const material = new THREE.ShaderMaterial({
        uniforms: {
          uTexture: { value: texture },
          uMouse: { value: new THREE.Vector2(0.5, 0.5) },
          uHover: { value: 0.0 },
          uTime: { value: 0.0 },
          uRGBShift: { value: 0.0 },
          uWave: { value: 0.0 },
          uRotation: { value: 0.0 },
        },
        transparent: true,
        vertexShader: `
          uniform float uHover;
          uniform float uWave;
          uniform float uTime;
          uniform float uRotation;
          varying vec2 vUv;
          
          void main() {
            vUv = uv;
            vec3 pos = position;
            
            // Wave distortion effect
            float wave = sin(pos.x * 0.02 + uTime * 2.0) * cos(pos.y * 0.02 + uTime * 2.0);
            pos.z += wave * uWave * 20.0;
            
            // Subtle 3D rotation on hover
            float angle = uRotation * 0.1;
            float cosA = cos(angle);
            float sinA = sin(angle);
            mat3 rotationY = mat3(
              cosA, 0.0, sinA,
              0.0, 1.0, 0.0,
              -sinA, 0.0, cosA
            );
            pos = rotationY * pos;
            
            gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
          }
        `,
        fragmentShader: `
          uniform sampler2D uTexture;
          uniform vec2 uMouse;
          uniform float uHover;
          uniform float uTime;
          uniform float uRGBShift;
          uniform float uWave;
          varying vec2 vUv;

          // Noise function for grain effect
          float random(vec2 st) {
            return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);
          }

          void main() {
            // Pixelated block effect
            float blocks = 10.0;
            vec2 blockUv = floor(vUv * blocks) / blocks;
            float distance = length(blockUv - uMouse);
            float effect = smoothstep(0.5, 0.0, distance);
            
            // Multi-directional distortion
            vec2 distortion = vec2(
              sin(uTime * 3.0 + vUv.y * 10.0) * 0.01,
              cos(uTime * 2.0 + vUv.x * 10.0) * 0.01
            ) * effect * uHover;
            
            distortion += vec2(0.025) * effect * uHover;
            
            // RGB chromatic aberration with dynamic shift
            float shift = uRGBShift * 0.006 * (1.0 + sin(uTime * 5.0) * 0.3);
            vec4 texR = texture2D(uTexture, vUv + distortion + vec2(shift, shift * 0.5));
            vec4 texG = texture2D(uTexture, vUv + distortion);
            vec4 texB = texture2D(uTexture, vUv + distortion - vec2(shift, -shift * 0.5));
            
            float alpha = texG.a;
            vec3 finalRGB = vec3(texR.r, texG.g, texB.b);
            
            // Color grading on hover
            finalRGB = mix(finalRGB, finalRGB * vec3(1.2, 1.0, 1.3), uHover * 0.4);
            
            // Brightness pulse
            finalRGB += 0.12 * uHover * (1.0 + sin(uTime * 8.0) * 0.2);
            
            // Film grain effect
            float grain = random(vUv + uTime * 0.1) * 0.03;
            finalRGB += grain * uHover;
            
            // Vignette effect on hover
            vec2 center = vUv - 0.5;
            float vignette = 1.0 - length(center) * 0.8;
            finalRGB = mix(finalRGB, finalRGB * vignette, uHover * 0.3);
            
            // Saturation boost
            float luminance = dot(finalRGB, vec3(0.299, 0.587, 0.114));
            finalRGB = mix(vec3(luminance), finalRGB, 1.0 + uHover * 0.5);
            
            gl_FragColor = vec4(finalRGB, alpha);
          }
        `,
      });

      const plane = new THREE.Mesh(geometry, material);
      plane.position.x = rect.left + rect.width / 2 - window.innerWidth / 2;
      plane.position.y = -(rect.top + rect.height / 2 - window.innerHeight / 2);

      scene.add(plane);
      planes.push({ plane, img });
    });

    /* ---------------- SMOOTH SCROLL SYNC ---------------- */
    let scrollTimeout;
    window.addEventListener('scroll', () => {
      clearTimeout(scrollTimeout);
      
      planes.forEach(({ plane, img }) => {
        const rect = img.getBoundingClientRect();
        
        gsap.to(plane.position, {
          x: rect.left + rect.width / 2 - window.innerWidth / 2,
          y: -(rect.top + rect.height / 2 - window.innerHeight / 2),
          duration: 0.6,
          ease: "power3.out"
        });
      });

      // Add wave effect while scrolling
      scrollTimeout = setTimeout(() => {
        planes.forEach(({ plane }) => {
          gsap.to(plane.material.uniforms.uWave, {
            value: 0,
            duration: 0.8,
            ease: "power2.out"
          });
        });
      }, 150);
    });

    /* ---------------- RESPONSIVE RESIZE WITH ANIMATION ---------------- */
    let resizeTimeout;
    window.addEventListener('resize', () => {
      clearTimeout(resizeTimeout);
      
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.position.z = getCameraDistance();
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);

      resizeTimeout = setTimeout(() => {
        planes.forEach(({ plane, img }) => {
          const rect = img.getBoundingClientRect();
          
          plane.geometry.dispose();
          plane.geometry = new THREE.PlaneGeometry(rect.width, rect.height);
          
          gsap.to(plane.position, {
            x: rect.left + rect.width / 2 - window.innerWidth / 2,
            y: -(rect.top + rect.height / 2 - window.innerHeight / 2),
            duration: 0.5,
            ease: "power2.out"
          });
        });
      }, 100);
    });

    /* ---------------- ADVANCED RENDER WITH MULTIPLE EFFECTS ---------------- */
    function animate() {
      requestAnimationFrame(animate);
      time += 0.01;
      
      updateSmoothMouse();

      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObjects(planes.map(p => p.plane));

      // Reset all planes with smooth GSAP animations
      planes.forEach(({ plane }) => {
        plane.material.uniforms.uMouse.value.set(-1, -1);
        plane.material.uniforms.uTime.value = time;
        
        gsap.to(plane.material.uniforms.uHover, {
          value: 0,
          duration: 0.8,
          ease: "power3.out"
        });
        
        gsap.to(plane.material.uniforms.uRGBShift, {
          value: 0,
          duration: 0.8,
          ease: "power3.out"
        });

        gsap.to(plane.material.uniforms.uWave, {
          value: 0,
          duration: 0.6,
          ease: "power2.out"
        });

        gsap.to(plane.material.uniforms.uRotation, {
          value: 0,
          duration: 0.7,
          ease: "power2.out"
        });
      });

      // Apply advanced hover effects
      if (intersects.length > 0) {
        const { object, uv } = intersects[0];
        object.material.uniforms.uMouse.value.copy(uv);
        
        gsap.to(object.material.uniforms.uHover, {
          value: 1,
          duration: 0.4,
          ease: "power2.out"
        });
        
        gsap.to(object.material.uniforms.uRGBShift, {
          value: 1,
          duration: 0.4,
          ease: "power2.out"
        });

        gsap.to(object.material.uniforms.uWave, {
          value: 1,
          duration: 0.5,
          ease: "power2.out"
        });

        gsap.to(object.material.uniforms.uRotation, {
          value: 1,
          duration: 0.6,
          ease: "power2.out"
        });

        // Subtle camera movement toward hovered plane
        gsap.to(camera.position, {
          x: object.position.x * 0.02,
          y: object.position.y * 0.02,
          duration: 1,
          ease: "power2.out"
        });
      } else {
        // Reset camera position
        gsap.to(camera.position, {
          x: 0,
          y: 0,
          duration: 1.2,
          ease: "power2.out"
        });
      }

      renderer.render(scene, camera);
    }

    animate();
  </script>
</body>
</html>